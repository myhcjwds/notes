### Node 学习随记

#### 1. Module 和 exports

> 在node中，没有全局作用域，只有模块作用域，外部访问不到内部，内部也访问不到外部,那么模块间如何通信

- 当加载一个模块的时候，被加载模块的代码在第一次加载的时候会执行一遍

##### module.exports

- 被加载模块可以使用 node 提供 的 module.exports  来绝对向外暴露的内容（不设置的话默认为一个空对象）   *module 在node.js 模块中一般都表示本模块的意思*

  > require 函数真是实现：

  ```javascript
  function require(/* ... */) {
    const module = { exports: {} }; // exports 默认为空对象
    ((module, exports) => {
      // 模块代码在这。在这个例子中，定义了一个函数。
      function someFunc() {}
      exports = someFunc;
      // 此时，exports 不再是一个 module.exports 的快捷方式，
      // 且这个模块依然导出一个空的默认对象。
      module.exports = someFunc;
      // 此时，该模块导出 someFunc，而不是默认对象。
    })(module, module.exports);
    return module.exports;
  }
  ```

##### exprot

- `export` 和 `module.exports` 指向的是同一个对象地址

- 最终 `require()` 函数返回的是 `module.exports `  中的数据

  > 所以当 `module.exports` 属性被一个新的对象完全替代时，也会重新赋值 `export` , 	> `require` 的数据肯定也会变成新值；但是，如果给 `export` 对象改变地址的话，	   > `module.exports`不会改变 `requrie`的值自然也就不会发生变化；**可以将 `export` 想象成 `module.exports` 的快捷方式**

  ​











### 杂记

- 在node中，全局模块的使用不需要加载，而非全局模块则需要加载。

  process 模块在使用的时候无需通过 require( )来加载该函数，可以直接使用，而 fs 模块不是全局模块，需要加载来使用  `var fs = require('fs')`  

- Node 即是单线程的，又是异步非阻塞I/O

- data 参数的数据类型是一个 buffer 对象 ，里面保存的就是一个一个的字节（理解为字符数组）
  把buffer对象转化为字符串，用`toString`方法 默认 `utf8`

- 文件操作的 `./` 相对路径，相对的是执行 node 命令的路径

  > 解决：
  >
  > `__durbane`：表示当前正在执行的 js 文件所在的目录
  >
  > `__filename`: 表示当前正在执行的 js 文件的完整路径 
  >
  > 两者都是本地变量，使用时不用加载

  使用路径拼接的时候我们可以使用node提供的一个**path模块**，他可以更智能的识别反斜杠的存在和操作系统的兼容性，是我们的程序更简洁，兼容性更好

- node 错误优先规则，在node回调中，一般都是用err当做第一个回调参数

- try-catch 只能捕获 同步中的错误，异步中的错误无法用 trycatch来捕获，对于异步操作，要通过判断错误号（err.code）来进行出错处理

- 在请求服务器的时候，请求的url就只是一个标识，无其他作用

- require 模块加载是同步的

- 当加载一个模块的时候，被加载模块的代码在第一次加载的时候会执行一遍，并缓存起来，后续加载的话就不会执行代码

- node.js 遵循了 CommonJS 语法规范

- 在node中，没有全局作用域，只有模块作用域，外部访问不到内部，内部也访问不到外部